#include "stdint.h"
#include "../Inc/BIT_MATH.h"
#include "../Inc/STATUS.h"

#include "../Inc/RCC_config.h"
#include "../Inc/RCC_private.h"
#include "../Inc/RCC_interface.h"


int8_t RCC_Int8SetClockSrc(int8_t Copy_int8ClockType , int8_t Copy_int8Status)
{
	int8_t Local_int8ErrorState = OK;
	int32_t Local_int32ClkCounter = 0;


	switch (Copy_int8ClockType)
	{
	case HSE_CLK :
		if(Copy_int8Status == RCC_ON)
		{
			/*Enable HSE*/
			SET_BIT(RCC->CR,HSEON);
		}

		else if(Copy_int8Status == RCC_OFF)
		{
			/*Disable HSE*/
			CLR_BIT(RCC->CR,HSEON);
		}

		else
		{
			Local_int8ErrorState = NOK;
		}
		/*Waiting for ready flag*/
		while((GET_BIT(RCC->CR,HSERDY) == NOT_READY) && (Local_int32ClkCounter < RCC_CLK_TIMEOUT))
		{
			Local_int32ClkCounter++;
		}
		/*HSE is not ready and Timeout is reached*/
		if (Local_int32ClkCounter == RCC_CLK_TIMEOUT)
		{
			Local_int8ErrorState = NOK;
		}

		break;

	case HSI_CLK :
		if(Copy_int8Status == RCC_ON)
		{
			/*Enable HSI*/
			SET_BIT(RCC->CR,HSION);
		}

		else if(Copy_int8Status == RCC_OFF)
		{
			/*Disable HSI*/
			CLR_BIT(RCC->CR,HSION);
		}

		else
		{
			Local_int8ErrorState = NOK;
		}
		/*Waiting for ready flag*/
		while((GET_BIT(RCC->CR,HSIRDY) == NOT_READY) && (Local_int32ClkCounter < RCC_CLK_TIMEOUT))
		{
			Local_int32ClkCounter++;
		}
		/*HSI is not ready and Timeout is reached*/
		if (Local_int32ClkCounter == RCC_CLK_TIMEOUT)
		{
			Local_int8ErrorState = NOK;
		}
		break;

	case PLL_CLK :
		if(Copy_int8Status == RCC_ON)
		{
			/*Enable PLL*/
			SET_BIT(RCC->CR,PLLON);
		}

		else if(Copy_int8Status == RCC_OFF)
		{
			/*Disable PLL*/
			CLR_BIT(RCC->CR,PLLON);
		}

		else
		{
			Local_int8ErrorState = NOK;
		}

		/*Waiting for ready flag*/
		while((GET_BIT(RCC->CR,PLLRDY) == NOT_READY) && (Local_int32ClkCounter < RCC_CLK_TIMEOUT))
		{
			Local_int32ClkCounter++;
		}
		/*PLL is not ready and Timeout is reached*/
		if (Local_int32ClkCounter == RCC_CLK_TIMEOUT)
		{
			Local_int8ErrorState = NOK;
		}
		break;

	default : Local_int8ErrorState = NOK;
	}

	return Local_int8ErrorState;

}

int8_t RCC_Int8SetSysClock(int8_t Copy_int8ClockType)
{
	int8_t Local_int8ErrorState = 0;

	switch (Copy_int8ClockType)
	{
	case RCC_HSE_CLK :

		break;

	case RCC_HSI_CLK :

		break;

	case RCC_PLL_CLK :

		break;

	default : Local_int8ErrorState = 1;
	}

	return Local_int8ErrorState;
}


int8_t RCC_Int8HSEConfig(int8_t Copy_int8DivisionScale)
{
	int8_t Local_int8ErrorState = OK;

	if (Copy_int8DivisionScale == DIV_BY_1)
	{
//		RCC->CFGR
//		CLR_BIT()
	}

	else if (Copy_int8DivisionScale == DIV_BY_2)
	{

	}

	else
	{
		Local_int8ErrorState = NOK;
	}
	return Local_int8ErrorState;

}


int8_t RCC_Int8PLLConfig(int8_t Copy_int8PLLMul , int8_t Copy_int8PLLSrc)
{

}

int8_t RCC_Int8PeripheralClkControl(int8_t Copy_int8PeripheralClk , int8_t Copy_int8PeripheralName)
{

}
